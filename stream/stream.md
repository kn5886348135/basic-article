Stream 是一系列的支持串行和并行集合操作的元素。

除了对象引用的流，还有原生的IntStream，LongStream，DoubleStream，这些都符合流的特征和限制。



为了提供计算，流的操作被组合到stream pipeline中。流管道由一个源(可以使数组、集合、生成器函数、IO流等)，0或者多个中间操作(将一个流转换成另一个流，比如filter)，一个终止操作(产生一个结果，比如count或者forEach)。

流是懒加载的，源数据上的计算只有在终止操作被初始化的时候才会执行，源数据只有在需要的时候才会被消费。



集合和流在支持一些表面相似的功能的时候，有不同的目标。

集合主要是关心高效管理和访问它们的元素。对比之下，流并不提供直接访问或者修改元素的方法，

反而关心声明式地描述源数据和在源数据集合上执行的计算操作。如果提供的流操作并不支持想要的功能，可以使用iterator和spliterator操作执行可控的遍历。



流管道可以被看做流上的查询操作。除非源数据被明确地设计为并发修改操作(比如ConcurrentHashmap)，在查询的时候修改流的源数据可能导致不可预测的、错误的行为。



多数的流操作可以接收描述用户指定的行为的参数。为了保证正确的行为，这些行为参数(方法)必须是NonInterference(不能修改流的源数据)，多数情况下必须是Statelessness(他们的结果不应该依赖任何在流管道操作期间会发生改变的状态)，这些参数总是Function的实例，经常也可以用Lambda表达式和方法引用。除非另有说明，这些参数必须是非空的。



流应该被操作(调用中间操作或者终止操作)仅仅一次。这排除了"分叉的"流，也就是同一个源数据提供两个或者多个管道或者同一个流的多次遍历。如果流的实现检测到流被重复使用，可能会抛出IllegalStateException。但是，因为一些流操作可以返回他们的接收者，并不是创建一个新的流对象，在所有场景下都不可能会检测到重复使用。



流有一个close方法，并且实现了AutoCloseable接口，但是几乎所有的流实例实际上不需要在使用后关闭。通常只有当流的源数据是IO通道(比如Path和Charset返回的)会要求关闭。多数流是被集合、数组、函数支持的，这些并不需要特殊的资源管理。(如果一个流确实需要关闭，可以在try资源语句代码块中被声明为资源)



流管道可以执行串行或者并行操作。这个执行模式是流的一个属性。流被创建的时候，有一个初始化的串行或者并行操作选择(stream、parallelStream两个方法)。